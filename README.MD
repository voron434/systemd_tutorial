### 1. Запустите сервер

Зачем: Есть HTML страничка и установленный Python. Хочу поднять сайт на заранее арендованном сервере с последней версией Ubuntu LTS.

Цель: Захожу из браузера на IP адрес сервера и вижу сайт.

`python -m http.server 8000`

### 2. Создайте демона

Зачем: Если отключиться от сервера по ssh, то выключается и сайт

Цель: Отключаемся от сервера, но сайт всё ещё работает

#### Кто такой демон ?
Демон - это программа, которая работает на фоне, и которая продолжит работать даже после отключения терминала.
Мы хотим, чтобы наша команда запуска сервера стала демоном и работала на сервере независимо от терминала.

#### Кто такой SystemD ?

SystemD нам поможет контролировать этого демона, он будет запускать/останавливать/перезапускать демона (например, если будет ошибка или сервер перезапустится).
Для того, чтобы это сделать нам надо написать файл-инструкцию для SystemD, который должен называться `название_файла.service` и должен храниться в `/etc/systemd/system` . 


![image](git_assets/random_unit.png)

Этот файл может состоять из нескольких разделов. Названия разделов заключены в квадратные скобки. Например: `[UNIT]`, `[SERVICE]`, `[INSTALL]`.
Сейчас для нашей задачи понадобится раздел `[SERVICE]`.

#### Зачем нужен раздел [SERVICE] ?
Это обязательный раздел, в котором хранится основная конфигурация демона.
И минимальная инструкция, которая должна быть в этом разделе это `ExecStart=`.

В `ExecStart=` нужно передать полный путь и аргументы команды, которую нужно запустить при старте демона.

>Собственно название говорит за себя: Execute (at) Start - Выполнить при старте/в начале

Давайте напишем наш первый файл и назовем его `http_server_test.sevice`:
```
[Service]
ExecStart=python -m http.server 8000
```

Теперь нам нужно его запустить. Тут на помощь приходит `systemctl` это инструмент, который помогает работать с нашими файлами-инструкциями.
Помогает запускать/останавливать/перезапускать и проверять состояние наших файлов и многое другое.

Итак, запустить наш файл мы можем с помощью команды `systemctl start название_файла`. Кстати, название файла можно написать без суффикса `.service`.

В нашем случае мы набираем `systemctl start http_server_test`, нажимаем `Enter` и консоль нам отвечает:

```bash
# systemctl start http_server_test
Failed to start http_server_test.service: Unit http_server_test.service has a bad unit file setting.
See system logs and 'systemctl status http_server_test.service' for details.
```

Вольный перевод: Неудалось запустить ваш файл http_server_test.service: в нём плохие инструкции. Наберите `systemctl status http_server_test.service` , чтобы узнать что случилось.

Отлично! Тут мы узнаём, что у `systemctl` есть еще одна команда `systemctl status название_файла.service` (*на самом деле, как и с командой `systemctl start` название файла можно писать без суффикса `.service`*).
Это команда позволяет узнать о состоянии нашего файла, запущен ли он, остановлен или может что-то с ним случилось.

Давайте наберём `systemctl status http_server_test`. Получаем такой ответ:

![image](git_assets/status_bad_setting.png)

Давайте разберем, что в нём написано:
- 3-я строка сверху: `Active: inactive (dead)` - говорит нам о том, что наш файл-инструкция неактивен (мёртв)
- 3-я строка снизу (выделено красным): `/etc/systemd/system/http_server_test.service:2: Executable "python" not found in path "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"` - говорит о том, что конкретно случилось? какая ошибка произошла?

В данном случае она говорит, что SystemD в соответствии с нашей инструкцией `ExecStart=python -m http.server 8000` искал `python` и не смог его найти.
Действительно, если посмотреть, то конкретно на нашем сервере нет такой директории по такому адресу, но есть `python3` и `python3.8` (*это мы узнали вручную посмотрев эту директорию*).

Окей, давайте исправим наш файл-инструкцию:
```
[Service]
ExecStart=python3 -m http.server 8000
```

Запустим её с помощью уже знакомой нам команды `systemctl start http_server_test`.
Проверим её состояние с помощью команды, с которой мы только что познакомились `systemctl status http_server_test` и получаем такой ответ:

![image](git_assets/status_active_running.png)

Разберем, что написано в этот раз:
- 2-я строка сверху: `●http_server_test.service`. Мы видим, что кружок возле названия нашего файла стал зелёным, а в прошлый раз был черный.
- 4-я строка сверху: `Active: active (running)`. Слова `active (running)` означают "активный (запущен)". Кстати, как и кружок они стали зелеными, а в прошлый раз они были красными.

*Мы поняли, что зелёный цвет - это хороший знак.*

Теперь давайте проверим сайт, пройдем в браузере по адресу `ip-сервера:8000` и что мы видим? Мы запустили сайт!

![image](git_assets/landing.png)

А наш файл точно работает? И наш сайт продолжит работать даже после отключения терминала? Давайте убедимся в этом. Выйдите из терминала или наберите команду `exit`.
```bash
# exit
logout
Connection to 84.38.180.108 closed.
```

*Сайт продолжает работать! Супер!*


(?) Подсказки: 
как создать файл? ( `vim /etc/systemd/system/http_server_test.service` )

### 3. Добавьте в автозапуск
Зачем: Сервер иногда приходится перезапускать из-за обновления ПО и изменения настроек. Ещё хостинг провайдер периодически обновляет софт, чтобы закрыть свежие уязвимости, и самостоятельно перезапускает сервер.

Цель: Перезапускаем сервер, сайт запускается самостоятельно

Что будет если сервер перезагрузится?

Попробуем его перезагрузить, набираем `reboot now`, и видим, что сайт не работает.

![image](git_assets/landing_off.png)

#### Кто такой target?

Мы хотим, чтобы наш файл запускался во время запуска системы, чтобы это сделать сначала нам надо понять как вообще запускается машина и вся эта система.

Если совсем просто, то существует несколько уровней (очередей) запуска системы:
- сначала идет запуск "железа"
- потом загрузка самой ОС Linux
- и только потом идёт SystemD, а он дальше запускает все нужные программы.

Но сам SystemD тоже делит программы на уровни запуска программ (всего у него их восемь).

Каждый уровень представлен как своего рода "группа запуска (файлов-инструкций)", которая содержит в себе ссылки на файлы-инструкции (как наши).
Эти группы называются target'ами и хранятся в файлах с названиями `название_файла_группы.target`.
Если коротко, то предназначение target'ов - это группировать другие файлы-инструкции и запускать или останавливать их оптом.

Файлы этих групп также как и файлы-инструкций состоят из таких же разделов (за исключением раздела `[SERVICE]`). Вы также можете писать свои собственные target'ы.

Вот пример файла target'a:
```bash
[Unit]
Description=mysite
Requires=nginx.service mysql.service hhvm.service backup.timer
After=nginx.service mysql.service hhvm.service backup.timer
```

В этом примере используется рздел `[UNIT]`, который мы не разбирали (сейчас нам это и не нужно знать), но мы сейчас разберем, что написано внутри этого раздела.

Обратите внимание на строчку `Requires=`, с английского переводится как `Требует`, это значит, что эта группа требует запуска всех файлов-инструкций, которые в ней перечислены.

Конкретно в этом примере требуется запуск следующих файлов-инструкций `nginx.service`, `mysql.service`, `hhvm.service` и `backup.timer`. То есть, этот target оптом запустит эти файлы-инструкции.

#### Кто такой multi-user.target?

Итак, я упоминал, что у SystemD есть уровни и каждый уровень представлен как своего рода "группа запуска" и эти группы называются target'ами.
Вот эти target'ы: `deafault.target`, `graphical.target`, `multi-user.target`, `resque.target`, `emergency-target`, `halt.target`, `reboot.target`, `poweroff.target`.

Нас интересует `multi-user.target`, по-русски он называется "многопользовательский режим", это когда запущены все программы запущены, но без графического интерфейса, то есть можно контролировать их работу только через терминал.
> Логично можно догадаться, что когда есть графический интерфейс - это когда запущен target `graphical.target`.

В общем, нам нужно сделать так, чтобы наш файл-инструкцию `http_server_test.service` включили в группу `multi-user.target`.
То есть, чтобы в файле target'a `multi-user.target` появилась ссылка на наш `http_server_test.service`, и тогда когда будут запускаться файлы-инструкции из `multi-user.target` запустится и наш.

#### Кто такой раздел `[INSTALL]` ?

Чтобы это сделать нам нужно немного изменить наш файл.
Нужно добавить в него еще один раздел `[INSTALL]`.
В этом разделе мы описываем настройки зависимости от других файлов-инструкций и других настроек системы.

Например,
- `RequiredBy=` Какие для каких файлов-инструкций **требуется** запуск нашего файла-инструкции? То есть без нашего файла другой файл не запустится совсем.
- `WantedBy=` Для каких запуск нашего файла **желателен**? Эта инструкция похожа на предыдущую, но не такая строгая. То есть другой файл запустится даже если наш не запустится.
- `Alias=` Эта инструкция описывает какой будет псевдоним для нашего файла.

Для нашей задачи подойдет инструкция `WantedBy=`. Мы должны дать такую инструкцию: `WantedBy=multi-user.target`
> В переводе на человеческий это значит: *"Запустите наш файл-инструкцию, когда будете запускать другие файлы из группы `multi-user.target` "*

Итак, наш файл `http_server_test.service` приобретает такой вид:
```
[Service]
ExecStart=/usr/bin/python3 -m http.server 8000

[Install]
WantedBy=multi-user.target
```

Изменяем, запускаем `systemctl start http_server_test` и смотрим состояние `systemctl status http_server_test`.

![image](git_assets/added_install_section.png)

Вроде всё отлично, пишет что `active (running)` и сайт работает.

Перезапускаем сервер и видим, что сайт не работает. В чем проблема?

Наберем `systemctl status http_server_test` и видим следующее:

![image](git_assets/inactive_disabled.png)

Да, действительно, наш файл-инструкция не запущен `inactive (dead)` (неактивен (мертв)).

Почему? Посмотрим на строчку, которую в прошлый раз мы не разобрали - `Loaded`.

`Loaded: loaded (/etc/systemd/system/http_server_test.service; disabled; vendor preset: enabled)`

Здесь написано, что наш файл загружен (`loaded`) и дальше есть слово `disabled` - в этом слове и кроется ответ.

У нашего файла может быть несколько состояний:
- `enabled` - файл-инструкция включен в автозагрузку
- `disabled` - файл-инструкция не включен в автозагрузку
- `masked` - файл-инструкция скрыт, вы его не можете запустить
- `static` - файл-инструкция в автозагрузке, и вы не можете его отключить

Логично, что нам нужен первый вариант `enabled`.

Чтобы наш файл сделать `enabled` нам нужно запустить команду `systemctl enable http_server_test`.

Давайте сделаем это, и получаем следующий ответ:

![image](git_assets/enabled_symlink_created.png)
`Created symlink /etc/systemd/system/multi-user.target.wants/http_server_test.service → /etc/systemd/system/http_server_test.service.`
это значит, что строка `http_server_test.service` в target'e `multi-user.target` ссылается на наш файл-инструкцию `http_server_test.service`, который находится в `/etc/systemd/system/`.

Ну теперь-то наверное получилось? Перезагрузим сервер и проверим.

Да, действительно всё сработало, сайт работает.

### 4. Автозапуск в случае сбоя
Зачем: Если сервер упадёт с ошибкой, то так и продолжит лежать

Цель: Убиваем процесс через kill, но он продолжает работать

Казалось бы, работа сделана, можно закочить этот туториал, но на самом деле нет.

Что будет если в процессе работы поломатеся программа `http.server`, `python-интерпретатор` или просто произойдет какая-либо ошибка, которая остановит работу нашего файла-инструкции `http_server_test`?

Давайте проверим это, резко прервем его работу. Сделать это можно с помощью команды `systemctl kill http_server_test` - эта команда "убивает" процесс (работу нашего файла).

Окей, видим, что сайт перестал работать. Что делать?

#### Кто такой `Restart`

Поправить это можно с помощью добавления иструкции `Restart=` в раздел `[SERVICE]`.

В инструкции `Restart=` мы задаем перезагрузку нашего файла-инструкции при определенных обстоятельствах завершения программы.

Например,
- "при ошибках": `on-failure` 
- "при успешном выходе/выполнении программы":  `on-success`
- "всегда (несмотря на причину остановки программы)": `always`

Есть и другие варианты, их можете посмотреть в этой подробной таблице и подобрать свой вариант для какой-нибудь другой своей ситуации.

![image](git_assets/about_restart.png)

А для нашего случая сейчас подойдет вариант `always`, то есть мы хотим, чтобы наш файл запускался всегда, несмотря какая была причина её остановки - ошибка ли, убили ли, все равно, надо перезапустить наш файл.

Итак, мы редактируем наш файл и теперь он стал таким:

```
[Service]
ExecStart=/usr/bin/python3 -m http.server 8000
Restart=always

[Install]
WantedBy=multi-user.target
```

Давайте проверим работает ли наша инструкция `Restart=always`. Для этого сначала запустим нашу программу и потом убьём её.

Запускаем с помощью команды `systemctl start http_server_test`

...и нам прилетает следующий ответ:
```bash
# systemctl start http_server_test
Warning: The unit file, source configuration file or drop-ins of http_server_test.service changed on disk. Run 'systemctl daemon-reload' to reload units.
```

Автоский перевод: *Внимание: ваш файл-инструкция был изменен. Запустите команду `systemctl daemon-reload`, чтобы перезагрузить ваш файл.*

И тут мы знакомимся с командой `systemctl daemon-reload` - эта команда, как вы поняли из сообщения, перезагружает.
Хотя и присутствует слово "перезагрузка", но на самом деле SystemD не "перезагружает", а как бы проводит ревизию файлов-инструкций и если что-то изменилось в каком-либо файле, то SystemD запустит этот файл применив эти изменения.

В общем, если вы что-то изменили в файле, то всегда запускайте эту команду `systemctl daemon-reload`.

>Вы спросите почему мы её до этого не запускали? Ведь мы и до этого делали изменения в файле.
Да, это правда, но тогда, если помните, мы перезагружали сервер (`reboot now`) и поэтому SystemD перезапускался и запускал уже обновленный файл.

Итак, запускаем команду `systemctl daemon-reload`.

Теперь запускаем наш файл-инструкцию с помощью команды `systemctl start http_server_test`.

C помощью команды `systemctl status http_server_test` убедимся, что он запустился 

![image](git_assets/after_daemon_reload.png)


Запустился и сайт работает. Теперь убьём его с помощью команды `systemctl kill http_server_test`.

Проверим его состояние `systemctl status http_server_test`

![image](git_assets/after_kill2.png)

Супер! Всё работает - и файл, и сайт работают.

#### Кто такой PID

Теперь обратите внимание на строчку `Main PID: 1705` на скриншоте сверху и `Main PID: 1510` на скриншоте до него.

Я вам в прошлый раз не переводил, но в этот раз придётся:
`Main PID` (Main Process IDentifier) - `Идентификатор Главного Процесса`.

То есть, идентификатор (по-русски "айдишник") нашего файла-инструкции, что это такое?

Если коротко, то в Linux каждая запущенная программа является единым процессом и она имеет свой номерок.

Так вот, на скриншотах видно, что вроде бы запущен один и тот же наш файл `http_server_test`, но почему-то айдишники различаются.

Различаются они потому что первый процесс под номером `1510` мы убили (помните?), но из-за инструкции `Restart=always` в нашем файле SystemD немедленно перезапустил файл,
 и получился новый процесс с новым номером `1705`.

### 5. Посмотреть лог обращений к серверу
Зачем: при отладке удобно видеть список запросов, прилетающих на веб-сервер

Цель: видим лог прилетающих запросов в режиме реального времени

Иногда нам нужно посмотреть, что происходит с нашими процессами на сервере.

Это можно сделать запустив команду `journalctl`. Будет показана вся история с самого начала.

![image](git_assets/journalctl.png)

Если добавить аргумент `-b`, то можно посмотреть только последние (самые свежие) записи - полная команда `journalctl -b`.


Если нужно посмотреть историю по определенному файлу-инструкции, то выполните команду `journalctl -u название_файла`. В нашем случае это `journalctl -u http_server_test`.

![image](git_assets/journalctl_u_http_server.png)

Если добавить аргумент `-f` возле `-u`, то можно будет отслеживать историю по файлу в режиме реального времени - полная команда `journalctl -f -u название_файла`.

### Читать дальше

1. https://tproger.ru/translations/how-to-love-systemd/
2. https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files (Аналог на русском https://linux-notes.org/pishem-systemd-unit-fajl/)
3. https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units
4. https://pikabu.ru/story/systemd_dlya_samyikh_malenkikh_chast_i_znakomstvo_4285483
5. [Документация SystemD](https://www.freedesktop.org/software/systemd/man/systemd.service.html)